---
title: 마스터링 이더리움 4장 암호학
date: 2021-06-30 06:00:00
category: blockchain
draft: false
---

이더리움의 기반 기술에는 암호학이라는(cryptography) 기술이 중요하게 사용되고 있다.

이더리움에서는 공개키 암호화(Pulbic Key Cryptography, PKC)를 사용한다. 이 시스템에서는 개인키와 공개키라는 한 쌍을 제공한다.

개인키가 소유자만 알고 있는 비밀키이고 공개키는 누구나 알아도 되는 값이다. 예를들어서 현실세계로 가보면 우리는 계좌번호를 누구나에게 알려주고 그 주소로 돈을 입금하게 한다.

그리고 그 계좌번호의 비밀번호를 이용해서 신원을 증명함으로써 돈을 출금한다. 물론 은행 창구에 가면 신분증도 요구하지만 단순히 통장을 들고 ATM 에 가면 비밀번호만으로도 돈을 뽑을 수 있으니 말이다.

이더리움에서도 마찬가지로 공개키라는 것을 사람들에게 알려주고 그곳에 돈을 보내게 하고 개인키로 신원을 증명해 소유권을 갖는다. 여기까지오면 당연히 개인키라는 것은 신중히 보관해야 한다는 것을 알 수 있다. 그리고 분실 시 되찾을 방법이 없다. 은행에서는 통장 비밀번호를 잊어버리면 신분증 같은 것으로 신분을 증명하고 비밀번호를 되찾게 도와주지만 블록체인 세계에는 그런 것이 없기 때문에 한 번 비밀키를 잊어버리면 그 돈은 영영 찾이 못한다. 따라서 비밀키를 종이 같은 것에 써두는 것도 좋다.

이더리움에서는 공개키 암호화를 사용해서 위에서 설명한 비밀키와 공개키를 만든다.

사용자가 돈을 소비하고 싶은 경우를 생각해보자. 돈을 소비한다는 것은 그 돈을 누군가에게 보낸다는 것이고, 그것은 트랜잭션이라는 형태로 블록체인상에 기록이 된다.

"A 가 B 에게 돈을 보낸다." 라는 트랜잭션을 블록체인에 전파하는 것은 누구나 할 수 있다. 중요한 것은 그 트랜잭션을 정말 A 가 보낸게 맞냐는 것이다. 이것을 증명하기 위해 사용되는 것이 **디지털 서명**이다.

사용자는 "A 가 B 에게 돈을 보낸다." 라는 트랜잭션만 보내는게 아니라 서명 데이터를 함께 보낸다. 서명을 할 때는 그 사용자의 개인키를 이용해 서명한다.

그러면 그 트랜잭션을 보는 사람들이 그 서명 데이터를 보고 검증을 할 것이다. 그때 A 의 개인키에 상응하는 공개키가 이용이 되는데 그 공개키를 이용하면 그 서명이 올바른 것인지 검증할 수 있다.

> 하나의 개인키에는 하나의 공개키만 존재한다.

그 공개키는 트랜잭션 서명 데이터를 보낼 때 함께 보낼 수 있지만 이더리움에서는 복구 키를 정해두었기 때문에 서명 데이터만으로도 공개키를 얻어낼 수 있다. 그리고 그 공개키를 이용해 정말 A 가 보낸 거래가 맞는지 검증할 수 있는 것이다.

그러면 개인키가 무엇이고 어떻게 생성하는지 알아보자.

## 개인키

개인키는 단순히 무작위로 선택한 숫자다. 엄~청 큰 숫자이기 때문에 무작위로 골랐다고 해서 다른 사람들과 겹칠 일은 거의 없다고 보면 된다. 왜 큰 숫자냐 하면 개인키는 0보다 크며 2^256 보다 작은 값이기 때문이다.

> 2^256 은 10진수로 10^77, 즉 77자리 숫자다. 비교를 해보자면 우리가 보는 우주는 10^80 개의 원자를 포함하는 것으로 추정된다.

그래서 개인키는 오프라인에서도 만들 수 있다.

> 임의의 숫자를 고르기 위해서 프로그래밍 언어나 웹 사이트에서 제공하는 간단한 난수 생성 프로그램은 사용하면 안 된다. 왜냐면 그 난수 생성기들은 어느정도 예측이 가능하기 때문이다.
> 그래서 개인키를 만들기 위해서 보안성 있게 난수를 잘 고르는 것이 굉장히 중요하다.

다음은 임의로 생성한 16진수 형식의 개인키다.

`8da4ef21b864d2cc526dbdb2a120bd2874c36c9d0a1fb7f8c63d7f7a8b41de8f`

> 16진수는 2자리당 1바이트를 먹는다. 저 문자열은 32자리이므로 총 64 바이트라는 것을 알 수 있다. 64 바이트 = 256 비트다. (1 바이트 = 8 비트)

## 공개키

이더리움 공개키는 타원 곡선에 있는 점으로 타원 곡선 방정식을 만족하는 x 와 y 좌표의 집합을 의미한다. 이 공개키 또한 숫자다. 그리고 이 숫자는 개인키로부터 단반향으로만 계산할 수 있다. 개인키가 있는 상태에서는 공개키를 쉽게 계산할 수 있지만, 공개키로는 개인키를 계산할 수 없다는 뜻이다.

이더리움에서는 `secp256k1` 이라는 타원곡선 함수를 사용한다. `y^2=x^3 + 7` 식을 만족하는 타원곡선 함수다. 그리고 이더리움에는 미리 정의해둔 기준점이라는 것이 있다. 이 점은 앞에서 언급한 함수 위에 존재하는 점이다.

타원곡선 함수 특징상 곡선 위의 한 점과 상수를 곱할 경우 그 값 또한 곡선 위의 한 점이 된다.

개인 키를 구하기 위한 공식은 다음과 같다.

`공개키 = 개인키 x 기준점 G`

이때 개인키는 숫자이므로 공개키 또한 타원 곡선 위의 한점이라는 것을 알 수 있다.

결론적으로 개인키와 이 기준점을 곱하면 나오는 점을 직렬화한 값이 공개키가 된다.

x = 6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b

y = 83b5c38e5e2b0c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0

이더리움은 압축 안된 공개키를 사용하기 때문에 04 prefix 를 사용한다. 따라서 `0x + x + y` 를 해준다.

`046e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b83b5c38e5e2b0c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0`

이렇게 공개키를 개인키로부터 구할 수 있다. 개인키와 공개키 모두 단순한 숫자라는 것을 잊지 말자.

## 주소

해시 함수에 대해서 먼저 알아보자. 해시 함수란 임의 크기의 데이터를 고정된 크기의 데이터로 매핑하는데 사용하는 함수다.

이 해시함수에는 여러 알고리즘이 있고 이더리움에서는 keccak-256 해시함수를 사용한다.

keccak-256 해시 함수를 이용해 위에서 구한 공개키의 해시를 계산한다.

`2a5bc342ed616b5ba5732269001d3f1ef827552ae1114027bd3ecf1f086ba0f9` (32 byte, 64 char)

공개키의 마지막 20바이트만 추출해내면 그것이 주소가 된다.

`001d3f1ef827552ae1114027bd3ecf1f086ba0f9` (20 byte, 40 char)

## References

http://www.yes24.com/Product/Goods/73165236

https://steemit.com/kr-dev/@modolee/mastering-ethereum-3
