---
title: JPA - 객체지향 쿼리 언어
date: 2020-10-12 17:10:64
category: java
draft: false
---

## JPQL

Java Persistence Query Language 은 엔티티 객체를 조회하는 객체지향 쿼리다.

SQL 을 추상화해서 특정 데이터베이스에 의존하지 않는다. 그리고 SQL 보다 간결하다.

## Criteria

JQPL 을 생성하는 빌더 클래스다. Criteria 의 장점은 문자가 아닌 query.select(m).where(...) 처럼 프로그래밍 코드로 JPQL 을 작성할 수 있다는 점이다.

장점

- 컴파일 시점에 오류를 발견할 수 있다.
- IDE 를 사용하면 코드 자동완성을 지원한다.
- 동적 쿼리를 작성하기 편하다.

그런데, Criteria 가 가진 장점이 많지만 모든 장점을 상쇄할 정도로 복잡하고 장황하다. 그리고 코드도 한 눈에 들어오지 않는다.

## QueryDSL

Criteria 처럼 JPQL 빌더 역할을 한다. 장점은 코드 기반이면서 단순하고 사용하기 쉽다. 그리고 작성한 코드고 JPQL 과 비슷해서 한눈에 드렁온다.

## Native SQL

JPA 는 SQL 을 직접 사용할 수 있는 기능을 지원한다.

JPQL 을 사용해도 가끔은 특정 데이터베이스에 의존하는 기능을 사용해야 할 때가 있다.

## JDBC 직접 사용, 마이바티스와 같은 SQL 매퍼 프레임워크 사용

JPA 는 JDBC 커넥션을 획득하는 API 를 제공하지 않으므로 JPA 구현체가 제공하는 방법을 사용해야 한다.

JPA 를 우회해 SQL 을 실행하기 전에 영속성 컨텍스트를 수동으로 플러시해서 데이터베이스와 영속성 컨텍스트를 동기화 해야한다. AOP 를 이용하면 깔끔하게 해결할 수 있다.

## JPQL NEW

NEW 명령어를 사용해 반환받을 클래스를 지정할 수 있다.

```java
TypedQuery<UserDTO> query =
	em.createQuery("SELECT new jpabook.jpql.userDTO(m.username, m.age)
	FROM Member m", UserDTO.class);

List<UserDTO> resultList = query.getResultList();
```

NEW 명령어를 사용할 때의 주의점이다.

- 패키지 명을 포함한 전체 클래스 명을 입력해야 한다.
- 순서와 타입이 일치하는 생성자가 필요하다.

## JPQL GROUP BY, HAVING

통계 쿼리는 보통 전체 데이터를 기준으로 처리하므로 실시간으로 사용하기에 부담이 많다. 결과가 아주 많다면 통계 결과만 저장하는 테이블을 별도로 만들어 두고 사용자가 적은 새벽에 통계 쿼리를 실행해서 그 결과를 보관하는 것이 좋다.

## JPQL 페치 조인과 일반 조인

JPQL 은 결과를 반환할 때 연관관계까지 고려하지 않는다. 단지 SELECT 절에 지정한 엔티티를 조회할 뿐이다.

회원 컬렉션을 지연 로딩으로 설정하면, 프록시나 아직 초기화하지 않은 컬렉션을 반환한다.

즉시로딩으로 설정하면 회원 컬렉션을 즉시 로딩하기 위해 쿼리를 한 번 더 실행한다.

반면에 페치 조인을 사용하면 연관된 엔티티도 함께 조회한다.

```sql
select t
from Team t join fetch t.members
where t.name = 'TeamA'
```

변환된 sql

```sql
SELECT
	T.*, M.*
FROM TEAM T
INNER JOIN MEMBER M ON T.ID=M.TEAM_ID
WHERE T.NAME = 'TeamA'
```

## 페치 조인의 특징

페치 조인을 사용하면 SQL 한 번으로 연관된 엔티티들을 함께 조회할 수 있어서 SQL 호출 횟수를 줄여 성능을 최적화 할 수 있다.

**페치 조인**은 글로벌 로딩 전략보다 우선한다.

`@OneToMany(fetch = FetchType.LAZY)` 처럼 엔티티에 직접 적용하는 로딘 전략은 애플리케이션 전체에 영향을 미치므로 글로벌 로딩 전략이라 부른다.

최적화를 위해 글로벌 로딩 전략을 즉시 로딩으로 설정하면 애플리케이션 전체에서 항상 즉시 로딩이 일어난다. 물론 일부는 빠를 수 있지만 전체로 보면 사용하지 않는 엔티티를 자주 로딩하므로 오히려 성능에 악영향을 미칠 수 있다. **따라서 글로벌 로딩 전략은 될 수 있으면 지연 로딩을 사용하고 최적화가 필요하면 페치 조인을 사용하는 것이 효과적이다.**

또한 페치 조인을 사용하면 연관된 엔티티를 쿼리 시점에 조회하므로 지연 로딩이 발생하지 않는다. 따라서 **준영속 상태에서도 객체 그래프를 탐색할 수 있다.**

## 페치 조인의 제한

- 페치 조인 대상에는 별칭을 줄 수 없다.
  - JPA 표준에서는 지원하지 않지만 하이버네이트를 포함한 몇몇 구현체들은 페치 조인에 별칭을 지원한다.
  - 데이터 무결성이 깨질 수 있고, 2차 캐시와 함께 사용할 때 부작용이 많으므로 조심해야 한다.
- 둘 이상의 컬렉션을 페치할 수 없다.
- 컬렉션을 페치 조인하면 페이징 API 를 사용할 수 없다.

## 묵시적 조인

단일 값 연관 필드로 경로 탐색을 하면 SQL 에서 내부 조인이 일어난다.

- 명시적 조인: JOIN 을 직접 적어주는 것
  ex) SELECT m FROM Member m JOIN [m.team](http://m.team) t
- 묵시적 조인: 경로 표현식에 의해 묵시적으로 조인이 일어나는 것, 내부 조인만 할 수 있다.
  ex) SELECT [m.team](http://m.team) FROM member m

주의 사항

- 항상 내부 조인이다.
- 컬렉션은 경로 탐색의 끝이다. 컬렉션에서 경로 탐색을 하려면 명시적으로 조인을 해서 별칭을 얻어야 한다.

## References

[자바 ORM 표준 JPA 프로그래밍](https://www.aladin.co.kr/shop/wproduct.aspx?itemid=62681446)
