---
title: 데이터 중심 애플리케이션 설계 1장
date: 2020-11-02 09:11:15
category: development
draft: false
---

현대 애플리케이션은 compute-intensive 이기 보다는 data-intensive 하다.

오늘날 애플리케이션의 속도를 제한하는 요소는 데이터의 양, 데이터의 복잡도, 데이터의 변화 속도다.

이 책에서는 다음 세가지에 관심사를 둔다.

**신뢰성(Reliability)**

하트웨어나 소프트웨어 결함, 인적 오류 같은 역경에 직면하더라도 시스템은 올바르게 동작해야 한다.

**확장성(Scalability)**

시스템의 데이터의 양, 트래픽 양, 복잡도가 증가해도 이를 처리할 수 있는 적절한 방법이 있어야한다.

**유지보수성(Maintainability)**

모든 사용자가 시스템에서 생산적으로 작업할 수 있게 해야 한다.

## 신뢰성

잘못될 수 있는 일을 **결함(Fault)** 이라 부른다.

이것을 예측하고 대측할 수 있는 시스템을 **결함성(fault-tolerent) 또는 탄력성(resilent)**을 지녔다고 말한다.

일반적으로 결함은 사양에서 벗어난 시스템의 한 구성 요소로 정의된다.

결함은 장애와 동일하지 않다. 장애는 사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우다.

> 넷플릭스의 카오스 몽키는 고의적으로 개별 프로세스를 무작위로 죽여 테스트해서 이것을 처리하는 접근 방식이다.

### 하드웨어 결함

소프트웨어 내결함성을 사용하거나 하드웨어 중복성을 추가해 전체 장비의 손실을 견딜 수 있는 시스템으로 점점 옮겨가고 있다.

이러한 시스템은 중단시간 없이 한 노드씩 패치해서 패치를 적용할 수 있다.

> AWS, GCP 와 같은 클라우드 플랫폼은 단일 장비 신뢰성보다 유연성(flexibility)과 탄력성(elasticity) 을 우선적으로 처리하게끔 설계되었다.

## 확장성

**확장성**은 증가한 부하에 대한 시스템 능력을 설명하는 데 사용하는 용어지만 시스템에 부여하는 일차원적인 표식이 아님에 주의하자.

"X는 확장 가능하다" 또는 "Y는 확장 가능하지 않다" 같은 말은 의미가 없다.

확장성을 논한다는 것은 "시스템이 특정 방식으로 커지면 이에 대처하기 위한 선택은 무엇인가?" 와 "추가 부하를 다루기 위해 계산 자원을 어떻게 투입할까"? 같은 질문을 고려한다는 의미다.

### 부하 기술하기

무엇보다 시스템의 현재 부하를 간결하게 기술해야 한다. 그래서 부하 성장 질문을 논의할 수 있다. 부하는 **부하 매개변수(load parameter)** 라 부르는 몇 개의 숫자로 나타낼 수 있다.

가장 적합한 부하 매개변수 선택은 시스템 설계에 따라 달라진다. 예를들어 TPS, DB 의 일기 대 쓰기 비율, 대화방의 동시 활성 사용자, 캐시 적중률이 있다.

평균적인 경우가 중요할 수 있고 소수의 극단적인 경우가 병목의 현상일 수 있는점 유의하자.

## 성능 기술하기

일단 시스템 부하를 기술하면 부하가 증가할 때 어떤 일이 일어나는지 조사할 수 있다.

다음 두가지 방법을 살펴보자.

- 부하 매개변수를 증가시키고 시스템 자원은 변경하지 않고 유지하면 시스템 성능은 어떻게 영향을 받을까?
- 부하 매개변수를 증가시켰을 때 성능이 변하지 않고 유지되길 원한다면 자원을 얼마나 많이 늘려야 할까?

하둡 같은 일괄 처리 시스템은 처리량에 관심을 두지만, 온라인 시스템에서 중요한 것은 응답 시간이다.

> **지연 시간**과 **응답 시간**을 종종 같은 뜻으로 사용하지만 동일하지 않다.
>
> 응답 시간은 클라이언트에서 본 관점으로, 요청을 처리하는 실제 시간 외에도 네트워크 지연과 큐 지연도 포함한다.
>
> 지연 시간은 요청이 처리되길 기다리는 시간으로, 서비스를 기다리며 Latent 상태인 시간을 말한다.

클라이언트가 반복해소 동일한 요청을 보내도 매번 응답시간이 다르다.

따라서 응답 시간은 단일 숫자가 아니라 분포로 생각해야 한다.

분포에서 산술평균을 사용할 수 있지만 일반적으로 좋은 지표가 아니기에 백분위를 사용하는 편이 좋다.

백분위는 **서비스 수준 목표(service level objective, SLO)**와 **서비스 수준 협약서(service level agreement, SLA)**에 자주 사용하고 기대 성능과 서비스 가용성을 정의하는 계약서에서 자주 등장한다.
다음 문장은 SLA의 한 예다.
"응답 시간 중앙 값이 200밀리초 미만이고 99분위가 1초 미만인 경우 정상 서비스 상태로 간주하며 서비스 제공 시간은 99.9% 이상이어야 한다."

이런 지표는 클라이언트의 기대치를 설정해 SLA 를 지키 못하면 고객이 환불을 요구할 수 있게 한다.

### 부하 대응 접근 방식

**Scaling up(vertical scaling), scaling out(horizontal scaling)** 과 같은 방법이 있다.

다수의 장비에 부하를 분산하는 아키텍처는 **비공유(shared-nothing)** 아키텍처라 부른다.

**탄력적**인 시스템은 부하 증가를 감지하면 컴퓨팅 자원을 자동으로 추가한다. 그렇지 않은 시스템은 수동으로 확장해야 한다.

탄력적인 시스템은 부하를 예측할 수 없을 만큼 높은 경우 유용하지만 수동으로 확장하는 시스템이 더 간단하고 운영상 예상치 못한 일이 더 적다.

다수의 장비에 Stateless 서비스를 배포하는 일은 간단하다. 그러나 Stateful 시스템을 분산 설치하는 것은 복잡하다.

특정 애플리케이션에 적합한 확장성을 갖춘 아키텍처는 주요 동작이 무엇이고 잘 하지 않는 동작이 뭇언지에 대한 가정을 바탕으로 구축한다. 이 가정은 곧 부하 매개변수가 된다.

스타트업 초기에는 미래의 부하에 대비해 확장하기보다는 빠르게 반복해서 제품 기능을 개선하는 작업이 좀 더 중요하다.

## 유지보수성

유지보수는 대부분의 소프트웨어 개발자가 싫어하는 일이지만 누군가는 해야하는 일이다.

그러나 유지보수 고통을 최소화하기 위해 소프트웨어를 설계할 수 있다.

다음 세가지 원칙을 지키자.

**운용성(operability)**

운영템이 시스템을 원할하게 운영할 수 있게 만들어라.

**단순성(simplicity)**

시스템의 복잡도를 최대한 제거해 엔지니어가 시스템을 이해하기 쉽게 만들어라.

**발전성(evolability)**

엔지니어가 이후에 시스템을 쉽게 변경할 수 있게 하라. 그래야 요구사항 변경 같은 예기치 않은 사례를 적용하기가 쉽다.

이 속성은 **유연성(extensibility)**, **수정 가능성(modifiability)**, **적응성(plasticity)**으로 알려져있다.

**신뢰성, 확장성을 달성하기 쉬운 해결책은 없다. 그보다 운용성, 단순성, 발전성을 염두에 두고 시스템을 생각하려 노력해야 한다.**

### 운용성: 운영의 편리함 만들기

운영은 자동화가 중요하다.

다음은 좋은 운영팀이 책임지는 일이다.

- 시스템 상태를 **모니터링**하고 상태가 좋지 않다면 빠르게 **복원**
- 시스템 **장애, 성능 저하** 등의 문제와 원인 추적
- 보안 패치를 포함해 소프트웨어와 플랫폼 최신 상태로 유지
- 시스템 간 영향을 확인해 문제 차단
- 문제를 예측해 미리 해결 (예를들어 용량 계획)
- 배포, 설정 관리 등을 위한 모범 사례와 도구 마련
- 플랫폼 이전과 같은 복잡한 유지보수 태스크 수행
- 설정 변경으로 인한 시스템 **보안 유지보수**

다음은 데이터 시스템이 할 수 있는 일이다.

- 좋은 **모니터링**으로 런타임 동작과 시스템 내부에 대한 **가시성** 제공
- 표준 도구를 이용해 **자동화**와 통합을 위한 우수한 지원 제공
- 개별 장비의 **의존성 회피**, 유지보수를 위해 장비를 내리더라도 시스템 전체에 영향을 주지 않고 계속해서 운영 가능해야 함.
- **좋은 문서**와 이해하기 쉬운 운영 모델 제공
- 만족할 만한 기본 동작을 제공하고, 필요할 때 기본 값을 다시 정의할 수 있는 **자유**를 관리자에게 부여
- 적절하게 자기 회복이 가능할 뿐 아니라 필요에 따라 **관리자가 수동으로 제어**할 수 있게 함.
- **예측 가능하게 동작하고 예기치 않은 상황을 최소화 함.**

### 단순성: 복잡도 관리

복잡도는 다양한 형태로 나타난다. 상태 공간의 급증, 모듈 간 강한 커플링, 복잡한 의존성, 일관성 없는 명명, 성능 문제 해결을 목표로 한 해킹, 임시방편으로 문제를 해결한 특수 사례가 있다.

개발자가 시스템을 이해하고 추론하기 어려워지면 시스템에 숨겨진 가정과 의도치 않은 결과 및 예기치 않은 상호작용을 간과하기 쉽다. 반대로 복잡도를 줄이면 소프트웨어 유지보수성이 크게 향상된다.

따라서 **단순성**이 구축하려는 시스템의 **핵심 목표**여야 한다.

시스템을 단순하게 만드다는 것이 기능을 줄인다는 것이 아니다. **우발적 복잡도**를 줄인다는 것이다.

**우발적 복잡도**는 사용자에게 보이는 문제에 내재하고 있지 않고 구현에서만 발생하는 것을 말한다.

우발적 복잡도를 제거하기 위한 가장 좋은 방법은 추상화다. 좋은 추상화는 깔끔하고 직관적인 외관 아래로 많은 세부 구현을 숨길 수 있다.

또한 좋은 추상화는 다양항 애플리케이션에서 사용 가능하다. 이러한 재사용은 비슷한 기승을 여러 번 재구현하는 것보다 효율적이고 고품질 소프트웨어로 이어진다.

> 예를들어, 고수준 프로그래밍 언어는 기계 언어, CPU 레지스터, 시스템 호출을 숨긴 추상화다.
>
> SQL 은 디스크에 기록하고 메모리에 저장한 복잡한 데이터 구조와 다른 클라이언트의 동시 요청과 고장후 불일치를 숨긴 추상화다.

우리는 이러한 좋은 추상화로 여러 기술의 내부 구현을 모르고도 잘 사용할 수 있다. 그런데 자기가 목표로하는 개발자가 더 높은 수준이라면
그 내부 구현을 이해하고 구현할 수 있는 능력을 길러야 한다고 생각한다.

### 발전성: 변화를 쉽게 만들기

변화에 적응하기 좋은 애자일, TDD, 리팩토링과 같은 기술 도구와 패턴을 사용한다.

발전성을 좋게 만드는 것은 시스템의 단순함과 추상화와 밀접한 연관이 있다.

## 정리

애플리케이션이 유용하려면 다양한 요구사항을 충족시켜야 한다. 다양한 요구사항에는 기능적 요구사항과 비기능적 요구사항이 있다.

**비기능적 요구사항**에는 보안, 신뢰성, 법규준수, 확장성, 호환성, 유지보수성 같은 것이 있다.

**신뢰성**은 결함이 발생해도 시스템이 올바르게 동작하게 만든다는 의미다.

**확장성**은 부하가 증가해도 좋은 성능을 유지하기 위한 **전략**을 의미한다. 확장성을 설명하려면 부화와 성능을 설명하는 방법과 지표가 필요하다.

**유지보수성**의 본질은 엔지니어와 운영 팀의 삶을 개선하는 데 있다. **좋은 추상화는 복잡도를 줄이고 쉽게 시스템을 변경할 수 있게** 하며 새로운 사용 사례에 적용하는 데 도움이 된다.

좋은 운용성이란 시스템의 건강 상태를 잘 관찰할 수 있고 시스템을 효율적으로 관리하는 방법을 보유한다는 의미다.

안타깝게도 애플리케이션을 신뢰할 수 있고 확장 가능하며 유지보수하기 쉽게 만들어주는 간단한 해결책은 없지만 여러 애플리케이션에서 계속 재현되는 특정 패턴과 기술이 있다.

이후 몇 개의 장에서 이것을 알아보자.

## References

[데이터 중심 애플리케이션 설계](http://www.yes24.com/Product/Goods/59566585)
