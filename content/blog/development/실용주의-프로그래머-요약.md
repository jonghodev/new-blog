---
title: 실용주의 프로그래머 요약
date: 2020-10-12 14:10:24
category: development
thumbnail: { thumbnailSrc }
draft: false
---

1. **깨진 창문을 내버려두지 말라. '깨진 창문'을 고치지 않는 채로 내버려 두지 말라. 발견하자마자 바로 고쳐라.** 적절히 고칠 시간이 충분하지 않다면 판자로 덮는 것만이라도 하라. 불쾌한 코드를 주석처리하거나, 아직 구현되지 않았음이라는 메시지를 표시하거나, 가짜 데이터로 대치해 놓거나 하라. 더 이상의 손상을 예방하기 위해 어떤 조치든 취하고 현 상황을 잘 관리하고 있다는 것을 보여줘라.
2. 깨끗한 설계와 강력하고 기술적인 프로젝트 리더, 그리고 그 설계 내에서 책임의 분배가 제대로 이해되도록 하는 것, 이런 것들로 개발자 간의 중복 문제를 다루어라.
3. 당신이 가진 생각이 딱 하나밖에 없다면, 그것만큼 위험한 것은 없다. -- 에밀 사르티에
4. 비난 대신 문제를 해결하라
5. 가정하지 마라. 증명하라.
6. 우리는 모든 가능한 에러(특히 의외의 것들)를 체크하는 것이 좋다고 했다. 그렇지만, 실제로 이렇게 하다보면 코드가 꽤 지저분해질 수 있다.
7. 왜 의존의 증가가 나쁠까? 시스템 어딘가의 무관한 변화가 여러분의 코드에 영향을 미칠 수 있는 위험이 커지기 때문이다.
8. '잘 정의된 단 하나의 책임만 가지는 것'이라는 말이야말로 모듈에 대한 좋은 정의가 된다.
9. **지금 잘 작동하는데 괜히 건드렸다 일을 만들필요가 있을까나? 우리는 그래야 할 몇 가지 이유를 생각해낼 수 있다.**
   - **정말로 제대로 돌아가는 것이 아닐지도 모른다. 우리에게만 그런 것 처럼 보일 수 있다.**
   - **여러분이 의존하는 조건이 단지 우연인 경우도 있다.**
   - **문서화되지 않은 동작은 라이브러리의 동작은 다음 릴리즈에서 변경될 가능성이 있다.**
   - **불필요한 추가 호출은 코드를 더 느리게 만든다.**
   - **추가로 호출한 루틴 때문에 새로운 버그들이 코드에 들어올 가능성이 있다.**
10. 맹목적으로 코딩하지 말라. 완전하게 이해하지 못한 어플리케이션을 빌드하려 하거나 익숙하지 않은 기술을 사용하려고 시도하는 행동은 우연에게 자기를 미혹해도 좋다는 초청장을 보내는 것과 다름 없다.
11. 계획을 세우고 그것을 바탕으로 진행해라. 머리 속에 있는 계획이든, 냅킨 뒤에 적어놓은 계획이든, CASE 도구로 만든 한쪽 벽면에 가득 찰 정도 계획이든 상관없다.
12. 신뢰할 수 있는 것에만 기대라. 우연한 일에나 가정에 의존하지 말라. 어떤 상황에서 신뢰할 만한 것과 아닌 것을 판단하지 못하겠거든, 일단 가장 최악의 상황을 가정하라.
13. **여러분의 가정을 문서로 남겨라.**
14. **코드만 테스트할 것이 아니라 여러분이 세운 가정도 테스트해 보아야 한다.**
15. 과거의 노예가 되지 말라. 기존 코드가 앞으로 짤 코드를 지배하도록 놓아두지 말라. 더 이상 적절한 코드가 아니라고 생각되면, 어떤 코드라도 교체할 수 있다.
16. 최고라고 언제나 최고는 아니다. 적당한 알고리즘을 선택할 때도 실용적이어야 할 필요가 있다. 가장 빠른 알고리즘이 언제나 가장 좋은 알고리즘은 아니다. 입력값의 규모가 작다면 단순한 삽입 정렬도 퀵정렬과 비슷한 성능을 내준다. 그러나 삽입 정렬을 작성하고 디버깅하는데 걸리는 시간은 퀵정렬보다 적다.
17. 리팩터링을 하지 않는 핑계로 자주 사용되는 이유가 일정의 압박이다. 하지만 이것은 설득력 있는 이유가 되지 못한다. 지금 리팩터링 하지 않으면, 일이 더 진척되었을 때, 곧 신경 써야 할 의존성이 더 많이 생겼을 때 문제를 고치기 위해 훨씬 더 많은 시간을 투자해야 한다. 그떄가 되면 일정에 더 여유가 생길까? 우리의 경험에 비추어 봤을 때 그런 일은 없다.
18. 일찍 리팩터링하고, 자주 리팩터링 하라.
19. 분명히 리팩터링은 천천히, 신중하게, 조심스럽게 진행해야 하는 작업이다. 마틴 파얼러는 손해보다 이득이 큰 방향으로 리팩터링을 하기 위한 다음 몇가지 간단한 조언을 제공한다.
    - 리팩터링과 새로운 기능 추가를 동시에 하지 말라.
    - 리팩터링을 시작하기 전 든든한 테스트 집합이 있는지 먼저 확인한다.
    - 단계를 작게 나누어서 신중하게 작업한다
20. 테스트 코드를 쉽게 접근할 수 있게 해놓는 것은, 매우 귀중한 두 가지 자원을 제공하는 것이다.

    - 여러분 모듈의 모든 기능을 어떻게 이용해야 하는지 보여주는 예제
    - 후일 코드 변경시 검증하기 위한 회귀 테스트를 구축할 수 있는 수단

21. 자신이 이해하지 못하는, 마법사가 만들어 준 코드는 사용하지 말라.
22. 요구사항 문서를 만들 때 생기는 큰 위험은 지나치게 자세히 서술하는 것이다. 좋은 요구사항 문서는 추상적이다. 요구사항에 관한 한 비지니스에 필요한 사항을 정확히 반영하는 가장 간단한 진술문이 최고다. 그렇다고 해서 모호하게 하라는 말은 아니다.
23. 요구사항 증가 관리의 핵심은, 새 기능이 일정에 미칠 영향을 프로젝트 후원자에게 인식시키는 것이다. (...)'기능 하나만 더'라는 소용돌이 속으로 빨려 들어가기는 무척 쉽다. 하지만 요구사항을 추적함으로써, '기능 하나만 더'가 실은 이번 달에 추가된 15번째 새 기능이었다는 사실을 분명히 알 수 있게 된다.
24. 품질은 팀의 이슈다. 만약 가장 부지런한 개발자라 해도 품질에 무심한 팀에 배치된다면 귀찮은 문제를 고치는 그의 열정은 줄어들 것이다.
25. 팀 전체가 깨진 창문(아무도 고치려고 하지 않는 사소한 결점)을 용납하지 않아야 한다. 팀은 상품의 품질에 대해 책임을 져야만 한다.
26. 무뚝뚝하고 과묵해 보이는 프로젝트 팀이야말로 최악이다. 그런 팀은 회의를 아무 체계 없이 하고, 나서서 말하는 이도 없다. 문서는 엉망진창이다. 어떤 문서도 닮은 데가 없고, 각기 다른 용어를 사용한다.
27. 훌륭한 프로젝트 팀은 뚜렷한 특성을 갖는다. 모든 사람이 좋아할 만한 잘 준비된 퍼포먼스를 보게 될 걸 알기 때문에 사람들은 회의를 기대한다. 그들이 생산해 내는 문서는 깔끔하고 정확하며 일관적이다. 팀은 한 목소리로 이야기한다. 심지어 유머감각도 있을 것이다.
28. 생각 없이 행할 수 있는 중요한 작업의 수가 늘어남에 따라 문명은 발전한다. -- 알프레드 노드 화이트헤드
29. 개발자 대부분은 테스트를 싫어한다. 코드가 어디에서 깨지는지 무의식적으로 알고 약한 지점을 피해 다니면서, 살살 테스트하려 한다. 실용주의 프로그래머들은 다르다. 우리는 지금 당장 버그를 찾아 나서도록 내몰리지만, 그 대신 나중에 다른 사람이 자기 버그를 발견하게 되는 수치를 피할 수 있는 것이다.
30. 프로젝트의 성공은 사용자들의 기대를 얼마나 잘 충족하는가에 따라 측정된다.
31. 옛 장인들은 자신의 작품에 서명하는 것을 자랑스러워했다. 여러분도 그래야 한다.
32. 우리는 소유권에 대한 긍지를 보고 싶다. "내가 이걸 만들었고, 내 작품의 품질을 보증합니다." 여러분의 서명이 품질의 보증수표로 인식되게 해야 한다. 사람들이 코드에 붙여진 여러분의 이름을 보고 그것이 튼튼하고 잘 작성되고 제대로 테스트되었으며 또 훌륭히 문서화되었을 것이라고 기대하도록 만들자. 진정으로 프로페션한 일. 진정한 프로페셔널이 작성한. 실용주의 프로그래머.

출처 [실용주의 프로그래머 요약](https://byjay.github.io/posts/programming/2018-11-04-the-progmatic-programmer/)
